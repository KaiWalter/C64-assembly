# Commodore 64 Assembly Development Guide

## Project Overview
This is a KickAssembler-based Commodore 64 (C64) development project focused on learning 6502 assembly fundamentals through practical C64 programs. The project demonstrates both Kernal routine calls and direct memory manipulation, with deployment to real C64 hardware via network.

## Architecture & Key Components

### Core Memory Layout
- **$0801-$080d**: BASIC startup (generated by `BasicUpstart2()`)
- **$1000+**: Main program code (where execution begins at `start:` label)
- **$0400**: Video matrix (screen RAM) - 1000 bytes for 40x25 character display
- **$2000-$27ff**: Charset data (1KB custom character definitions, when used)

### Key Pattern: Image-to-Charset Conversion
The `LoadPicture()` function imports GIF images and converts them to C64 single-color character format:
```
.var charsetPic = LoadPicture("2x2char.gif", List().add($000000, $ffffff))
.fill $200, charsetPic.getSinglecolorByte(2*(i>>3), i&7)  // Black/white palette
```
This handles 2x2 pixel mapping where the GIF is divided into charset tiles. Only used if custom charset is needed - most programs (like `hello.asm`) use the default C64 charset.

## Critical Developer Workflows

### Building
The project uses **KickAssembler** (Java-based assembler). Build process:
1. Parse assembly code and resolve symbols
2. Execute KickAssembler's pseudo-commands (`.print`, `.for`, `.var`, etc.)
3. Generate `.prg` file for C64 emulators or hardware (VICE, WinVICE, C64U)
4. Output symbol file (.sym) for debugging

**Quick launch**: Press **F5** to build and launch the `.prg` file in VICE emulator automatically.

**Memory validation**: Each `*=` directive sets the origin. The assembler performs three flex passes to resolve forward references and detects overlapping memory regions.

### Debugging
- **Symbol file** (hello.sym): Maps addresses to labels for VICE debugger
- **Build log** (bin/buildlog.txt) shows memory map and any assembly errors
- **Emulator debugging**: Test in VICE/WinVICE before running on real hardware
- **Hardware deployment**: Use `runc64u.ps1` script with `.prg` file to upload to C64U network device

## C64 Assembly Conventions

### Register Usage
- **A register**: Accumulator for arithmetic/logic operations
- **X/Y registers**: Index registers (addressing modes, loop counters)
- **Status register**: Modified by instructions; cleared with `cli`, disabled with `sei`

### Memory-Mapped I/O (Critical)
- **$d018**: Video chip register (character data location). Value `$18` = charset at $2000
- **$0400**: Video matrix (screen RAM) - 1000 bytes for 40x25 character display
- **$0400+40**: Screen line 1 (each line = 40 bytes)

### Code Patterns
1. **Text rendering**: Copy text bytes to screen RAM with double-width effect using offset arithmetic
2. **Character animation**: Modify character codes in real-time using accumulator math (`adc #$40`)
3. **Infinite loop**: `jmp *` to pause at current address

### String Printing Methods
Two approaches for displaying strings on the C64:

**Method 1: BASIC Print Routine** (Kernal address `$AB1E`)
- Setup: Load string address into A (LSB) and Y (MSB), then `jsr $AB1E`
- String must be null-terminated (`\$00`)
- Example from `hello.asm`:
```
lda #<str_to_print    // Load low byte of string address
ldy #>str_to_print    // Load high byte of string address
jsr PRINT_STRING_BASIC_ADDR  // Call Kernal PRINT routine
```

**Method 2: Direct Memory Write (POKE)** (Direct to `$0400`)
- Writes character codes directly to screen RAM
- More control over placement, no BASIC overhead
- Example from `hello.asm`:
```
ldx #0                // X = loop counter
DirectLoop:
  lda str_to_poke,x   // Load byte from string
  beq Done            // If null terminator, exit
  sta SCREEN_DIRECT_START,x  // Write to screen memory
  inx                 // Next character
  jmp DirectLoop
```
- Screen memory: 40 bytes per line, 25 lines total
- Offset calculation: `line * 40 + column` for position

## KickAssembler-Specific Features

### Pseudo-Commands (Not 6502 Instructions)
- `.var x = value` - Define mutable variable
- `.const y = value` - Define immutable constant
- `.for (var i=0; i<10; i++)` - Loop with variable scope
- `.print "text"` - Console output during assembly
- `.fill count, expr` - Repeat expression N times (loop variable `i` available)
- `.text "string"` - Convert ASCII string to C64 screen codes

### Function Library
- **Math**: `sqrt()`, `pow()`, `sin()`, `cos()` (Java Math library)
- **String**: `.substring()`, concatenation with `+`
- **Collections**: `List()` with `.add()`, `.get()` methods
- **Graphics**: `LoadPicture()` for image import, `.getSinglecolorByte()`, `.getMulticolorByte()`

### Constants & Labels
- Labels end with `:` and are memory addresses
- Memory location directive `* = $address` sets origin
- Named segments: `* = $2000 "Charset"` for readability

## Integration Points & Dependencies

### External Assets
- **2x2char.gif**: (Optional) Used by `LoadPicture()` if custom charset needed
- Format: Expected to be 2x2 pixel arrangement of character definitions
- Palette: Binary (black/white) for single-color C64 mode
- Most programs use default C64 charset instead

### Output Artifacts
- **.prg files**: Executable C64 programs in `bin/` directory
- **.sym files**: Debug symbols for VICE (maps addresses to labels)
- **buildlog.txt**: Assembly build output with memory map

## Common Pitfalls & Solutions

| Issue | Solution |
|-------|----------|
| "Unknown symbol" errors | Ensure label is defined before use OR use KickAssembler's 3-pass assembler (automatically handles forward refs) |
| Screen display garbled | Verify `$d018` is set to charset address AND screen data written to correct `$0400+offset` |
| Charset not loading | Confirm GIF file exists in src directory; check `getSinglecolorByte()` coordinates |
| Assembly warnings | Use `.print` statements in pseudo-code sections to debug variable values |

## Hardware Deployment (C64U Network Device)

The project includes `runc64u.ps1` PowerShell script for uploading compiled programs to real C64 hardware:

**Prerequisites**:
- C64U network device accessible on network
- 1Password CLI (`op` command) configured for credential management
- C64 credentials stored as "C64" item in 1Password with hostname and password fields (standard for this environment)

**Usage**:
```powershell
.\runc64u.ps1 .\bin\hello.prg
```

**How it works**:
1. Retrieves C64U hostname and password from 1Password ("C64" item)
2. Sends `.prg` file via HTTP POST to C64U device
3. C64U device executes the program on real hardware

**Credentials setup** (if needed):
```powershell
op item create --category login --title "C64" hostname=my-c64 password=secret-pwd
```

## File Editing Guidelines
- Maintain tab-based indentation (visible in existing code)
- Assembly mnemonics lowercase (match existing style)
- Comments use `//` for inline, placed on separate lines
- Separate data sections with `//---` dividers
